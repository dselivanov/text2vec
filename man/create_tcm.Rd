% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tcm.R
\name{create_tcm}
\alias{create_tcm}
\alias{create_tcm.itoken}
\alias{create_tcm.list}
\title{Term-Cooccurence Matrix construction.}
\usage{
create_tcm(itoken_src, vectorizer, verbose = FALSE, ...)

\method{create_tcm}{itoken}(itoken_src, vectorizer, verbose = FALSE, ...)

\method{create_tcm}{list}(itoken_src, vectorizer, verbose = FALSE, ...)
}
\arguments{
\item{itoken_src}{\code{list} of iterators over tokens - \code{itoken}.
Each element is a list of tokens = tokenized and normalized strings.}

\item{vectorizer}{\code{function} vectorizer function.}

\item{verbose}{\code{logical} print status messages}

\item{...}{- arguments to \link{foreach} function which is used to iterate
over \code{itoken_src} under the hood.}
}
\value{
\code{dgCMatrix} Term-Cooccurence Matrix
}
\description{
High-level function for Term-Cooccurence Matrix construction.
If parallel backend is registered, it will construct TCM in multiple threads.
}
\details{
User should keep in mind, that he/she should split data itself and
provide list of \link{itoken} iterators. Each element of \code{itoken_src}
will be handled in separate thread and at the end they will be combined.
}
\examples{
\dontrun{
data("movie_review")

# single threadx

tokens <- movie_review$review \%>\% tolower \%>\% word_tokenizer
it <- itoken(tokens)
v <- vocabulary(jobs)
vectorizer <- vocab_vectorizer(v, grow_dtm = FALSE, skip_grams_window = 3L)
tcm <- create_tcm(itoken(tokens), vectorizer)

# parallel version

# set to number of cores on your machine
N_WORKERS <- 1
splits <- split_into(movie_review$review, N_WORKERS)
jobs <- lapply(splits, itoken, tolower, word_tokenizer)
v <- vocabulary(jobs)
vectorizer <- vocab_vectorizer(v, grow_dtm = FALSE, skip_grams_window = 3L)
jobs <- lapply(splits, itoken, tolower, word_tokenizer)
doParallel::registerDoParallel(N_WORKERS)
tcm <- create_tcm(jobs, vectorizer)
}
}
\seealso{
\link{itoken}
}

